<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
		<title>HATETRIS @ Things Of Interest</title>
		<link rel="stylesheet" type="text/css" href="http://qntm.org/page/reset.css" />
		<link
			rel="shortcut icon"
			href="../../page/favicon.ico"
		/>
		<style type="text/css">
			body {
				font-family: arial;
			}
			p {
				margin: 10px;
			}
			td.cell {
				width: 25px;
				height: 25px;
				color: white;
				background-color: black;
				padding: 0;
				text-align: center;
				vertical-align: middle;
			}
		</style>
		<script type="text/javascript"><!--
			var NO_BYTE = -1;
			var base65536 = {
				encode: function(buf) {
					var strs = [];
					for(var i = 0; i < buf.length; i += 2) {
						var b1 = buf[i];
						var b2 = i + 1 < buf.length ? buf[i + 1] : NO_BYTE;
						var codePoint = {"0":13312,"1":13568,"2":13824,"3":14080,"4":14336,"5":14592,"6":14848,"7":15104,"8":15360,"9":15616,"10":15872,"11":16128,"12":16384,"13":16640,"14":16896,"15":17152,"16":17408,"17":17664,"18":17920,"19":18176,"20":18432,"21":18688,"22":18944,"23":19200,"24":19456,"25":19968,"26":20224,"27":20480,"28":20736,"29":20992,"30":21248,"31":21504,"32":21760,"33":22016,"34":22272,"35":22528,"36":22784,"37":23040,"38":23296,"39":23552,"40":23808,"41":24064,"42":24320,"43":24576,"44":24832,"45":25088,"46":25344,"47":25600,"48":25856,"49":26112,"50":26368,"51":26624,"52":26880,"53":27136,"54":27392,"55":27648,"56":27904,"57":28160,"58":28416,"59":28672,"60":28928,"61":29184,"62":29440,"63":29696,"64":29952,"65":30208,"66":30464,"67":30720,"68":30976,"69":31232,"70":31488,"71":31744,"72":32000,"73":32256,"74":32512,"75":32768,"76":33024,"77":33280,"78":33536,"79":33792,"80":34048,"81":34304,"82":34560,"83":34816,"84":35072,"85":35328,"86":35584,"87":35840,"88":36096,"89":36352,"90":36608,"91":36864,"92":37120,"93":37376,"94":37632,"95":37888,"96":38144,"97":38400,"98":38656,"99":38912,"100":39168,"101":39424,"102":39680,"103":39936,"104":40192,"105":40448,"106":41216,"107":41472,"108":41728,"109":42240,"110":67072,"111":73728,"112":73984,"113":74240,"114":77824,"115":78080,"116":78336,"117":78592,"118":82944,"119":83200,"120":92160,"121":92416,"122":131072,"123":131328,"124":131584,"125":131840,"126":132096,"127":132352,"128":132608,"129":132864,"130":133120,"131":133376,"132":133632,"133":133888,"134":134144,"135":134400,"136":134656,"137":134912,"138":135168,"139":135424,"140":135680,"141":135936,"142":136192,"143":136448,"144":136704,"145":136960,"146":137216,"147":137472,"148":137728,"149":137984,"150":138240,"151":138496,"152":138752,"153":139008,"154":139264,"155":139520,"156":139776,"157":140032,"158":140288,"159":140544,"160":140800,"161":141056,"162":141312,"163":141568,"164":141824,"165":142080,"166":142336,"167":142592,"168":142848,"169":143104,"170":143360,"171":143616,"172":143872,"173":144128,"174":144384,"175":144640,"176":144896,"177":145152,"178":145408,"179":145664,"180":145920,"181":146176,"182":146432,"183":146688,"184":146944,"185":147200,"186":147456,"187":147712,"188":147968,"189":148224,"190":148480,"191":148736,"192":148992,"193":149248,"194":149504,"195":149760,"196":150016,"197":150272,"198":150528,"199":150784,"200":151040,"201":151296,"202":151552,"203":151808,"204":152064,"205":152320,"206":152576,"207":152832,"208":153088,"209":153344,"210":153600,"211":153856,"212":154112,"213":154368,"214":154624,"215":154880,"216":155136,"217":155392,"218":155648,"219":155904,"220":156160,"221":156416,"222":156672,"223":156928,"224":157184,"225":157440,"226":157696,"227":157952,"228":158208,"229":158464,"230":158720,"231":158976,"232":159232,"233":159488,"234":159744,"235":160000,"236":160256,"237":160512,"238":160768,"239":161024,"240":161280,"241":161536,"242":161792,"243":162048,"244":162304,"245":162560,"246":162816,"247":163072,"248":163328,"249":163584,"250":163840,"251":164096,"252":164352,"253":164608,"254":164864,"255":165120,"-1":5376}[b2] + b1;
						var str = String.fromCodePoint(codePoint);
						strs.push(str);
					}
					return strs.join("");
				},

				decode: function(str) {
					var bufs = [];
					var done = false;
					for(var i = 0; i < str.length; i++) {
						var codePoint = str.codePointAt(i);
						var b1 = codePoint & ((1 << 8) - 1);
						var b2 = {"5376":-1,"13312":0,"13568":1,"13824":2,"14080":3,"14336":4,"14592":5,"14848":6,"15104":7,"15360":8,"15616":9,"15872":10,"16128":11,"16384":12,"16640":13,"16896":14,"17152":15,"17408":16,"17664":17,"17920":18,"18176":19,"18432":20,"18688":21,"18944":22,"19200":23,"19456":24,"19968":25,"20224":26,"20480":27,"20736":28,"20992":29,"21248":30,"21504":31,"21760":32,"22016":33,"22272":34,"22528":35,"22784":36,"23040":37,"23296":38,"23552":39,"23808":40,"24064":41,"24320":42,"24576":43,"24832":44,"25088":45,"25344":46,"25600":47,"25856":48,"26112":49,"26368":50,"26624":51,"26880":52,"27136":53,"27392":54,"27648":55,"27904":56,"28160":57,"28416":58,"28672":59,"28928":60,"29184":61,"29440":62,"29696":63,"29952":64,"30208":65,"30464":66,"30720":67,"30976":68,"31232":69,"31488":70,"31744":71,"32000":72,"32256":73,"32512":74,"32768":75,"33024":76,"33280":77,"33536":78,"33792":79,"34048":80,"34304":81,"34560":82,"34816":83,"35072":84,"35328":85,"35584":86,"35840":87,"36096":88,"36352":89,"36608":90,"36864":91,"37120":92,"37376":93,"37632":94,"37888":95,"38144":96,"38400":97,"38656":98,"38912":99,"39168":100,"39424":101,"39680":102,"39936":103,"40192":104,"40448":105,"41216":106,"41472":107,"41728":108,"42240":109,"67072":110,"73728":111,"73984":112,"74240":113,"77824":114,"78080":115,"78336":116,"78592":117,"82944":118,"83200":119,"92160":120,"92416":121,"131072":122,"131328":123,"131584":124,"131840":125,"132096":126,"132352":127,"132608":128,"132864":129,"133120":130,"133376":131,"133632":132,"133888":133,"134144":134,"134400":135,"134656":136,"134912":137,"135168":138,"135424":139,"135680":140,"135936":141,"136192":142,"136448":143,"136704":144,"136960":145,"137216":146,"137472":147,"137728":148,"137984":149,"138240":150,"138496":151,"138752":152,"139008":153,"139264":154,"139520":155,"139776":156,"140032":157,"140288":158,"140544":159,"140800":160,"141056":161,"141312":162,"141568":163,"141824":164,"142080":165,"142336":166,"142592":167,"142848":168,"143104":169,"143360":170,"143616":171,"143872":172,"144128":173,"144384":174,"144640":175,"144896":176,"145152":177,"145408":178,"145664":179,"145920":180,"146176":181,"146432":182,"146688":183,"146944":184,"147200":185,"147456":186,"147712":187,"147968":188,"148224":189,"148480":190,"148736":191,"148992":192,"149248":193,"149504":194,"149760":195,"150016":196,"150272":197,"150528":198,"150784":199,"151040":200,"151296":201,"151552":202,"151808":203,"152064":204,"152320":205,"152576":206,"152832":207,"153088":208,"153344":209,"153600":210,"153856":211,"154112":212,"154368":213,"154624":214,"154880":215,"155136":216,"155392":217,"155648":218,"155904":219,"156160":220,"156416":221,"156672":222,"156928":223,"157184":224,"157440":225,"157696":226,"157952":227,"158208":228,"158464":229,"158720":230,"158976":231,"159232":232,"159488":233,"159744":234,"160000":235,"160256":236,"160512":237,"160768":238,"161024":239,"161280":240,"161536":241,"161792":242,"162048":243,"162304":244,"162560":245,"162816":246,"163072":247,"163328":248,"163584":249,"163840":250,"164096":251,"164352":252,"164608":253,"164864":254,"165120":255}[codePoint - b1];
						if(b2 === undefined) {
							throw new Error("Not a valid Base65536 code point: " + Number(codePoint));
						}
						var buf = b2 === NO_BYTE ? [b1] : [b1, b2];
						if(buf.length === 1) {
							if(done) {
								throw new Error("Base65536 sequence continued after final byte");
							}
							done = true;
						}
						bufs.push(buf);
						if(codePoint >= (1 << 16)) {
							i++;
						}
					}
					return Array.prototype.concat.apply([], bufs);
				}
			};

			// global well attributes
			var wellWidth   = 10; // min=4
			var wellDepth   = 20; // min=bar
			var bar         = 4;

			// basic game config
			// note that these are cunningly placed with the least
			// useful first
			var pieces = {
				"S" : [
					{ "x" : 1, "y" : 2 },
					{ "x" : 2, "y" : 1 },
					{ "x" : 2, "y" : 2 },
					{ "x" : 3, "y" : 1 }
				],
				"Z" : [
					{ "x" : 1, "y" : 1 },
					{ "x" : 2, "y" : 1 },
					{ "x" : 2, "y" : 2 },
					{ "x" : 3, "y" : 2 }
				],
				"O" : [
					{ "x" : 1, "y" : 1 },
					{ "x" : 1, "y" : 2 },
					{ "x" : 2, "y" : 1 },
					{ "x" : 2, "y" : 2 }
				],
				"I" : [
					{ "x" : 0, "y" : 1 },
					{ "x" : 1, "y" : 1 },
					{ "x" : 2, "y" : 1 },
					{ "x" : 3, "y" : 1 }
				],
				"L" : [
					{ "x" : 1, "y" : 1 },
					{ "x" : 1, "y" : 2 },
					{ "x" : 2, "y" : 1 },
					{ "x" : 3, "y" : 1 }
				],
				"J" : [
					{ "x" : 1, "y" : 1 },
					{ "x" : 1, "y" : 2 },
					{ "x" : 1, "y" : 3 },
					{ "x" : 2, "y" : 1 }
				],
				"T" : [
					{ "x" : 1, "y" : 1 },
					{ "x" : 2, "y" : 1 },
					{ "x" : 2, "y" : 2 },
					{ "x" : 3, "y" : 1 }
				]
			};
			var transforms = {
				"L" : 1,
				"R" : 1,
				"D" : 1,
				"U" : 1
			};
			var orientations;

			var liveWell;
			var livePiece;
			var searchDepth; // min = 0, advisable max = 1
			var replayOut;
			var replayIn;
			var replayTimeoutId;

			// lock a piece into the well
			// create lines if necessary
			// increment score if line(s) made
			// this is the ONLY piece of code which modifies a well object!
			function addPiece(thisWell, thisPiece) {

				var orientation = orientations[thisPiece.id][thisPiece.o];

				// this is the top left point in the bounding box of this orientation of this piece
				var xActual = thisPiece.x + orientation.xMin;
				var yActual = thisPiece.y + orientation.yMin;

				// update the "highestBlue" value to account for newly-placed piece
				thisWell.highestBlue = Math.min(thisWell.highestBlue, yActual);

				// row by row bitwise line alteration
				// because we do this from the top down, we can remove lines as we go
				for(var row = 0; row < orientation.yDim; row++ ) {
					// can't negative bit-shift, but alas X can be negative
					thisWell.content[yActual + row] |= (orientation.rows[row] << xActual);

					// check for a complete line now
					// NOTE: completed lines don't count if you've lost
					if(
						   yActual >= bar
						&& thisWell.content[yActual + row] == (1 << wellWidth) - 1
					) {
						// move all lines above this point down
						for(var k = yActual + row; k > 1; k--) {
							thisWell.content[k] = thisWell.content[k-1];
						}

						// insert a new blank line at the top
						// though of course the top line will always be blank anyway
						thisWell.content[0] = 0;

						thisWell.score++;
						thisWell.highestBlue++;
					}
				}
			}

			// given a well and a piece, find the best possible location to put it
			// return the best rating found
			function bestWellRating(thisWell, pieceId, thisSearchDepth) {
				var thisPiece = {
					"id" : pieceId,
					"x"  : 0,
					"y"  : 0,
					"o"  : 0
				};

				// iterate over all possible resulting positions and get
				// best rating
				var bestRating = null;

				// move the piece down to a lower position before we have to
				// start pathfinding for it
				// move through empty rows
				while(
					   thisPiece.y + 4 < wellDepth    // piece is above the bottom
					&& thisWell.content[thisPiece.y + 4] == 0 // nothing immediately below it
				) {
					thisPiece = tryTransform(thisWell, thisPiece, "D"); // down
				}

				// push first position
				var piecePositions = [];
				piecePositions.push(thisPiece);

				var ints = [];
				ints[hashCode(thisPiece.x, thisPiece.y, thisPiece.o)] = 1;

				// a simple for loop won't work here because
				// we are increasing the list as we go
				var i = 0;
				while(i < piecePositions.length) {
					thisPiece = piecePositions[i];

					// apply all possible transforms
					for(var j in transforms) {

						var newPiece = tryTransform(thisWell, thisPiece, j);

						// transformation failed?
						if(newPiece == null) {

							// piece locked? better add that to the list
							// do NOT check locations, they aren't significant here
							if(j == "D") {

								// make newWell from thisWell
								// no deep copying in javascript!!
								var newWell = {
									"content" : [],
									"score" : thisWell.score,
									"highestBlue" : thisWell.highestBlue
								};
								for(var row2 = 0; row2 < wellDepth; row2++) {
									newWell.content.push(thisWell.content[row2]);
								}

								// alter the well
								// this will update newWell, including certain well metadata
								addPiece(newWell, thisPiece);

								// here is the clever recursive search bit
								// higher is better
								var currentRating = newWell.highestBlue + (
									thisSearchDepth == 0 ?
										0
									:
										// deeper lines are worth less than immediate lines
										// this is so the game will never give you a line if it can avoid it
										// NOTE: make sure rating doesn't return a range of more than 100 values...
										worstPieceRating(newWell, thisSearchDepth-1) / 100
								);

								// store
								if(bestRating == null || currentRating > bestRating) {
									bestRating = currentRating;
								}
							}
						}

						// transform succeeded?
						else {

							// new location? append to list
							// check locations, they are significant
							var newHashCode = hashCode(newPiece.x, newPiece.y, newPiece.o);

							if(ints[newHashCode] == undefined) {
								piecePositions.push(newPiece);
								ints[newHashCode] = 1;
							}
						}

					}
					i++;
				}

				return bestRating;
			}

			// initialise all variables for a new game or replay
			// can take whatever time
			function clearField() {

				// empty well
				// zero score
				// top blue = wellDepth = 20
				liveWell = {
					"content" : [],
					"score" : 0,
					"highestBlue" : wellDepth
				};
				for(var row = 0; row < wellDepth; row++) {
					liveWell.content.push(0);
				}
				drawWell(liveWell);

				drawScore();

				// first piece
				livePiece = worstPiece(liveWell);
				drawPiece(livePiece);

				// new replay
				replayOut = [];
			}

			// run once to setup
			// create the well in HTML
			// can take as long as needed
			function createPlayingField() {

				// create playing field
				var tbody = document.getElementById("welltbody");
				for(var i = 0; i < wellDepth; i++) {

					var tr = document.createElement("tr");
					tbody.appendChild(tr);

					for(var j = 0; j < wellWidth; j++) {
						var td = document.createElement("td");
						td.className = "cell";
						if(i == bar) {
							td.style.borderTop = "1px solid red";
						}
						tr.appendChild(td);
					}
				}

				// put some buttons on the playing field
				tbody.rows[0].cells[1].innerHTML = "<span onclick=\"inputHandler('U');\">&#x27f3;</span>";
				tbody.rows[1].cells[0].innerHTML = "<span onclick=\"inputHandler('L');\">&larr;</span>";
				tbody.rows[1].cells[1].innerHTML = "<span onclick=\"inputHandler('D');\">&darr;</span>";
				tbody.rows[1].cells[2].innerHTML = "<span onclick=\"inputHandler('R');\">&rarr;</span>";

				tbody.rows[0].cells[1].style.cursor = "pointer";
				tbody.rows[1].cells[0].style.cursor = "pointer";
				tbody.rows[1].cells[1].style.cursor = "pointer";
				tbody.rows[1].cells[2].style.cursor = "pointer";

				// also, generate those first piece rotations
				orientations = {};
				for(var i in pieces) {
					var bits = pieces[i];

					// generate an initial set of 0s and nulls for each orientation
					orientations[i] = [];
					for(var o = 0; o < 4; o++) {
						var rows = [];
						for(var row = 0; row < 4; row++) {
							rows.push(0);
						}
						orientations[i].push(
							{
								"xMin" : null, // minimum X coordinate of bits in this orientation (0, 1, 2 or 3)
								"yMin" : null, // minimum Y coordinate of bits in this orientation (0, 1, 2 or 3)
								"xDim" : null, // width
								"yDim" : null, // height
								"rows" : rows  // binary representation of the bits on each row
							}
						);
					}

					for(var j in bits) {
						var bit = { "x" : bits[j].x, "y" : bits[j].y };
						for(var o = 0; o < 4; o++) {
							orientations[i][o].rows[bit.y] += 1 << bit.x;

							// update extents
							if(orientations[i][o].xMin == null || bit.x < orientations[i][o].xMin) {
								orientations[i][o].xMin = bit.x;
							}

							if(orientations[i][o].yMin == null || bit.y < orientations[i][o].yMin) {
								orientations[i][o].yMin = bit.y;
							}

							// starts as xMax but we recalculate later
							if(orientations[i][o].xDim == null || bit.x > orientations[i][o].xDim) {
								orientations[i][o].xDim = bit.x;
							}

							// starts as yMax but we recalculate later
							if(orientations[i][o].yDim == null || bit.y > orientations[i][o].yDim) {
								orientations[i][o].yDim = bit.y;
							}

							// rotate this bit around the middle of the 4x4 grid
							bit = { "x" : 3 - bit.y, "y" : bit.x };
						}
					}

					for(var o = 0; o < 4; o++) {
						// turn Maxes into Dims
						orientations[i][o].xDim = orientations[i][o].xDim - orientations[i][o].xMin + 1;
						orientations[i][o].yDim = orientations[i][o].yDim - orientations[i][o].yMin + 1;

						// reduce that list of rows to the minimum
						// truncate top rows
						while(orientations[i][o].rows[0] == 0) {
							orientations[i][o].rows.shift();
						}

						// truncate bottom rows
						while(orientations[i][o].rows[orientations[i][o].rows.length-1] == 0) {
							orientations[i][o].rows.pop();
						}

						// shift left as many times as necessary
						for(row = 0; row < orientations[i][o].yDim; row++) {
							orientations[i][o].rows[row] >>= orientations[i][o].xMin;
						}
					}
				}
			}

			// draw this piece
			// no real need for optimisation here
			function drawPiece(thisPiece) {
				var orientation = orientations[thisPiece.id][thisPiece.o];
				for(var row = 0; row < orientation.yDim; row++ ) {
					for(var col = 0; col < orientation.xDim; col++) {
						if(orientation.rows[row] & 1 << col) {
							document
							.getElementById("welltbody")
							.rows[thisPiece.y + orientation.yMin + row]
							.cells[thisPiece.x + orientation.xMin + col]
							.style
							.backgroundColor = "red";
						}
					}
				}
			}

			// spit out a replay
			function drawReplay() {
				// encode the replay string for the user's benefit
				// UDLR
				var string = null;

				var replayType = "new";
				if(replayType === "old") {
					// replays must have an even number of moves in order
					// for the encoding to work correctly
					if(replayOut.length % 2 == 1) {
						replayOut.push("D");
					}

					// mark extra-depth games as such
					for(var i = 0; i < searchDepth; i++) {
						string += "#";
					}

					string = "";
					var transformPair = "";
					for(var i = 0; i < replayOut.length; i++) {
						transformPair += replayOut[i];

						// every two moves, append one more hex character
						// there is evidently no function to do this in JavaScript
						if(i % 2 == 1) {
							switch(transformPair) {
								case "LL": s = "0"; break;
								case "LR": s = "1"; break;
								case "LD": s = "2"; break;
								case "LU": s = "3"; break;
								case "RL": s = "4"; break;
								case "RR": s = "5"; break;
								case "RD": s = "6"; break;
								case "RU": s = "7"; break;
								case "DL": s = "8"; break;
								case "DR": s = "9"; break;
								case "DD": s = "A"; break;
								case "DU": s = "B"; break;
								case "UL": s = "C"; break;
								case "UR": s = "D"; break;
								case "UD": s = "E"; break;
								case "UU": s = "F"; break;
							}
							string += s;
							transformPair = "";
						}

						// add a space every 4 characters
						if(string.length % 5 == 4) {
							string += " ";
						}
					}
				}

				else {
					var rle = [];
					var current = null;
					replayOut.forEach(function(key) {
						if(
							rle.length > 0 &&
							rle[rle.length - 1].key === key &&
							rle[rle.length - 1].rl < 4
						) {
							rle[rle.length - 1].rl++;
						} else {
							rle.push({key: key, rl: 1});
						}
					});

					// Can't have an odd number of runs. This would break in mid-byte!
					if(rle.length % 2 === 1) {
						rle.push({key: "L", rl: 1});
					}
					
					rle = rle.map(function(run) {
						return {
							key: {"L" : 0, "R" : 1, "D" : 2, "U" : 3}[run.key],
							rl: run.rl - 1
						};
					});
					rle = rle.map(function(run) {
						return (run.key << 2) + run.rl;
					});

					var octets = [];
					for(var i = 0; i < rle.length; i += 2) {
						octets.push((rle[i] << 4) + rle[i + 1]);
					}

					string = base65536.encode(octets);
				}

				// and put it out there
				document.getElementById("replayOut").innerHTML = "replay of last game: " + string;
			}

			// this is an utter hack because the
			// "clear line" subroutine frequently gets called by the
			// evil piece generator, outside of normal gameplay
			function drawScore() {
				document.getElementById("score").innerHTML = liveWell.score;
			}

			// draw a well
			function drawWell(thisWell) {
				for(var col = 0; col < wellWidth; col++) {
					for(var row = 0; row < wellDepth; row++) {
						var color = (thisWell.content[row] & (1 << col)) ? "blue" : "black";
						document
						.getElementById("welltbody")
						.rows[row]
						.cells[col]
						.style
						.backgroundColor = color;
					}
				}
			}

			// generate a unique integer to describe the position and orientation
			// of this piece
			// x varies between -3 and (wellWidth-1) inclusive (range = wellWidth + 3)
			// y varies between 0 and (wellDepth+2) inclusive (range = wellDepth + 3)
			// o varies between 0 and 3 inclusive (range = 4)
			function hashCode(x, y, o) {
				return 4*((wellDepth + 3)*x + y) + o;
			}

			// accepts the input of a transformId and attempts to apply that
			// transform to the live piece in the live well.
			// returns false if the game is over afterwards,
			// returns true otherwise
			function inputHandler(transformId) {

				var newPiece = tryTransform(liveWell, livePiece, transformId);

				// transform failed?
				if(newPiece == null) {

					// piece has locked? better commit that live one then
					if(transformId == "D") {

						// alter the well, note the number of lines made
						addPiece(liveWell, livePiece);
						livePiece = null; // another may be generated later... if needed...
						drawScore();
					}
				}

				// transform succeeded
				else {
					livePiece = newPiece;
				}

				// update replayOut
				replayOut.push(transformId);

				// redraw well
				drawWell(liveWell);

				// is the game over?
				// it is impossible to get bits at row (bar - 2) or higher without getting a bit at row (bar - 1)
				// so there is only one line which we need to check
				if(liveWell.content[bar-1] > 0) {

					// GAME OVER STUFF:
					drawReplay();
					return false;
				}

				// otherwise the game continues

				// no live piece? make a new one
				// suited to the new world, of course
				if(livePiece == null) {
					livePiece = worstPiece(liveWell);
				}

				drawPiece(livePiece);
				return true;
			}

			function inputKey(event) {

				// only handle one key at a time.
				// if another key may be pressed,
				// this will be reactivated later
				document.onkeydown = null;
				event = event || window.event; // add for IE
				var transformId = null;

				switch(event.keyCode) {
					case 37: transformId = "L"; break;
					case 39: transformId = "R"; break;
					case 40: transformId = "D"; break;
					case 38: transformId = "U"; break;
					default: document.onkeydown = inputKey; return;
				}

				// make that move
				// transformId is sanitised
				var gameContinues = inputHandler(transformId);

				// optionally: continue the game
				if(gameContinues) {
					document.onkeydown = inputKey;
				}
			}

			// this has to be done recursively, sigh
			function inputReplayStep() {
				var transformId = replayIn.shift();

				// ignore non-replay characters
				// so that transformId is sanitised
				while(transforms[transformId] == undefined && replayIn.length > 0) {
					transformId = replayIn.shift();
				}

				// make that move
				// transformId is sanitised
				var gameContinues = inputHandler(transformId);

				// optionally: continue the game
				if(gameContinues) {
					// if there is still replay left, time in another step from the replay
					// otherwise, allow the user to continue the game
					if(replayIn.length > 0) {
						replayTimeoutId = setTimeout("inputReplayStep();", 50);
					} else {
						document.onkeydown = inputKey;
					}
				}
			}

			// clear the field and get ready for a new game
			function startGame(thisSearchDepth) {

				// there may be a replay in progress, this
				// must be killed
				clearTimeout(replayTimeoutId);

				// set depth of search
				searchDepth = thisSearchDepth;

				clearField();

				// prepare to take user input
				document.onkeydown = inputKey;
			}

			function startReplay() {

				// there may be a replay in progress, this
				// must be killed
				clearTimeout(replayTimeoutId);

				// disable user input while showing a replay
				document.onkeydown = null;

				// user inputs replay string
				var string = prompt() || ""; // change for IE

				replayIn = [];
				searchDepth = 0;

				// decode the string into a list of transforms
				// UDLR
				if(/^[0123456789ABCDEF# ]*$/.test(string)) {
					// "#" means "increase search depth"
					for(var i = 0; i < string.length; i++) {
						switch(string[i]) {
							case "0": replayIn.push("L", "L"); break;
							case "1": replayIn.push("L", "R"); break;
							case "2": replayIn.push("L", "D"); break;
							case "3": replayIn.push("L", "U"); break;
							case "4": replayIn.push("R", "L"); break;
							case "5": replayIn.push("R", "R"); break;
							case "6": replayIn.push("R", "D"); break;
							case "7": replayIn.push("R", "U"); break;
							case "8": replayIn.push("D", "L"); break;
							case "9": replayIn.push("D", "R"); break;
							case "A": replayIn.push("D", "D"); break;
							case "B": replayIn.push("D", "U"); break;
							case "C": replayIn.push("U", "L"); break;
							case "D": replayIn.push("U", "R"); break;
							case "E": replayIn.push("U", "D"); break;
							case "F": replayIn.push("U", "U"); break;
							case "#": searchDepth++;
							default: break;
						}
					}
				}

				else {
					var octets = base65536.decode(string);
					var rle = [];
					octets.forEach(function(octet) {
						rle.push(octet >> 4);
						rle.push(octet & ((1 << 4) - 1));
					});
					rle = rle.map(function(run) {
						return {key: run >> 2, rl: run & ((1 << 2) - 1)};
					});
					rle = rle.map(function(run) {
						return {
							key: {0: "L", 1: "R", 2: "D", 3: "U"}[run.key],
							rl: run.rl + 1
						};
					});
					rle.forEach(function(run) {
						for(var j = 0; j < run.rl; j++) {
							replayIn.push(run.key);
						}
					});

					// No support for search depth mods in this encoding.
				}

				// GO
				clearField();

				// line up first step (will trigger own later steps)
				inputReplayStep();
			}

			// attempt to apply a transform to the current piece in the well.
			// transform is successful: return a new, transformed piece
			// transform fails: return null
			function tryTransform(thisWell, thisPiece, transformId) {

				// can't alter in place
				var id = thisPiece.id;
				var x  = thisPiece.x;
				var y  = thisPiece.y;
				var o  = thisPiece.o;

				// apply transform (very fast now)
				switch(transformId) {
					case "L": x--;             break;
					case "R": x++;             break;
					case "D": y++;             break;
					case "U": o = (o + 1) % 4; break;
				}

				var orientation = orientations[id][o];
				var xActual = x + orientation.xMin;
				var yActual = y + orientation.yMin;

				if(
					   xActual < 0                            // make sure not off left side
					|| xActual + orientation.xDim > wellWidth // make sure not off right side
					|| yActual + orientation.yDim > wellDepth // make sure not off bottom
				) {
					return null;
				}

				// make sure there is NOTHING IN THE WAY
				// we do this by hunting for bit collisions
				for(var row = 0; row < orientation.rows.length; row++) { // 0 to 0, 1, 2 or 3 depending on vertical size of piece
					if(thisWell.content[yActual + row] & (orientation.rows[row] << xActual)) {
						return null;
					}
				}

				return { "id" : id, "x" : x, "y" : y, "o" : o };
			}


			// pick the worst piece that could be put into this well
			// return the piece
			// but not its rating
			function worstPiece(thisWell) {

				// iterate over all the pieces getting ratings
				// select the lowest
				var worstRating = null;
				var worstId = null;

				// we already have a list of possible pieces to iterate over
				var startTime = new Date().getTime();
				for(var id in pieces) {
					var currentRating = bestWellRating(thisWell, id, searchDepth);

					// update worstRating
					if(worstRating == null || currentRating < worstRating) {
						worstRating = currentRating;
						worstId = id;
					}

					// return instantly upon finding a 0
					if(worstRating == 0) {
						break;
					}
				}

				return {
					"id" : worstId,
					"x"  : Math.floor((wellWidth - 4) / 2),
					"y"  : 0,
					"o"  : 0
				};
			}

			// pick the worst piece that could be put into this well
			// return the rating of this piece
			// but NOT the piece itself...
			function worstPieceRating(thisWell, thisSearchDepth) {

				// iterate over all the pieces getting ratings
				// select the lowest
				var worstRating = null;

				// we already have a list of possible pieces to iterate over
				for(var id in pieces) {
					var currentRating = bestWellRating(thisWell, id, thisSearchDepth);
					if(worstRating == null || currentRating < worstRating) {
						worstRating = currentRating;
					}

					// if we have a 0 then that suffices, no point in searching further
					// (except for benchmarking purposes)
					if(worstRating == 0) {
						return 0;
					}
				}

				return worstRating;
			}
		// --></script>
	</head>
	<body style="margin: 50px 0 0 50px;" onload="createPlayingField();">
		<div style="float: left; margin: 0 50px 50px 0;">
			<table>
				<tbody id="welltbody">
				</tbody>
			</table>
		</div>
		<div style="margin: 0 50px 50px 0">
			<p><a href="http://qntm.org/hatetris">You're playing HATETRIS by Sam Hughes</a></p>
			<p><button type="button" onclick="startGame(0);">start new game</button></p>
			<p><button type="button" onclick="startReplay();">show a replay</button></p>
			<p><span id="score"></span></p>
			<p><span id="replayOut"></span></p>
			<script type="text/javascript"><!--
				var sc_project=667681; 
				var sc_invisible=1; 
				var sc_partition=5; 
				var sc_security="f56850e2"; 
				var sc_remove_link=1; 
			// --></script>
			<script type="text/javascript" src="http://www.statcounter.com/counter/counter_xhtml.js"></script>
			<noscript>
				<p><img
					class="statcounter"
					src="http://c6.statcounter.com/counter.php?sc_project=667681&amp;java=0&amp;security=f56850e2&amp;invisible=1"
					alt="website statistics"
				/></p>
			</noscript>
		</div>
	</body>
</html>